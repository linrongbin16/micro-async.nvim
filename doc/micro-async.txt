micro-async

------------------------------------------------------------------------------
                                                                  *M.callback()*
                               `M.callback`({co})
Create a callback function that resumes the current or specified coroutine when called.

Parameters~
{co} `(thread?)` The thread to resume, defaults to the running one.

Return~
`(fun(...): ...)`

------------------------------------------------------------------------------
                                                                      *M.void()*
                                 `M.void`({fn})
Create an async function that can be called from a synchronous context.
Cannot return values as it is non-blocking.

Parameters~
{fn} async `(fun(...):...)`

Return~
`(fun(...): micro-async.Task)`

------------------------------------------------------------------------------
                                                                       *M.run()*
                           `M.run`({fn}, {cb}, {...})
Run a function asynchronously and call the callback with the result.

Parameters~
{fn} async `(fun(...):...)`
{cb} `(fun(...))`
{...} `(any)`

Return~
micro-async.Task

------------------------------------------------------------------------------
                                                                      *M.wrap()*
                             `M.wrap`({fn}, {argc})
Wrap a callback-style function to be async.

Parameters~
{fn} `(fun(...): ...any)`
{argc} `(integer)`

Return~
async `(fun(...): ...)`

------------------------------------------------------------------------------
                                                                  *M.schedule()*
                                 `M.schedule`()
Yields to the Neovim scheduler



------------------------------------------------------------------------------
                                                                     *M.defer()*
                              `M.defer`({timeout})
Yields the current task, resuming when the specified timeout has elapsed.


Parameters~
{timeout} `(integer)`

------------------------------------------------------------------------------
                                                                      *M.work()*
                             `M.work`({fn}, {...})
Wrapper that creates and queues a work request, yields, and resumes the current task with the results.


Parameters~
{fn} `(fun(...):...)`
{...} `(...uv.aliases.threadargs)`

Return~
`(...uv.aliases.threadargs)`

------------------------------------------------------------------------------
                                                                    *M.system()*
                           `M.system`({cmd}, {opts})
Async vim.system


Parameters~
{cmd} `(string[])` Command to run
{opts} `(table)` Options to pass to `vim.system`

------------------------------------------------------------------------------
                                                                 *M.ui.select()*
                         `M.ui.select`({items}, {opts})

Parameters~
{items} `(any[])`
{opts} micro-async.SelectOpts
Return~
`(any)` `(optional)`, integer?

------------------------------------------------------------------------------
                                                                  *M.ui.input()*
                              `M.ui.input`({opts})

Parameters~
{opts} micro-async.InputOpts
Return~
`(string)` `(optional)`


 vim:tw=78:ts=8:noet:ft=help:norl:
